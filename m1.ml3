Migrant(
  capital : real,
  in_transit : bool
)

Location(
  x : real,
  y : real,
  type : {"std", "entry", "exit"},
  quality : real,
  resources
)

Information(
  quality : real,
  resources : real,
  quality_trust : real,
  resources_trust : real
)

Link(
  type : {"slow", "fast"},
  friction : real,
  distance : real
)

singleton World()

location:Location[1]<->[n]Migrant:migrants // migrants to locations
destination:Location[1]<->[n]Migrant:incoming // migrants on the move linked to their distination
links:Link[n]<->[n]Location:endpoints // location to the link object to another location
knowledge:Information[n]<->[1]Migrant:owner // migrants to their knowledge
subject:Location[1]<->[n]Information:information // pieces of information to the subject location
contacts:Migrant[n]<->[n]Migrant:contacts // contact network

weight_friction	 := 0.3
weight_control	 := 0.8
weight_info		 := 0.3
weight_resources := 0.5

n_ini_contacts	 := 10
ini_capital 	 := 500.0
costs_stay		 := 1.0
ben_resources	 := 5.0
costs_move		 := 5.0

p_keep_contact 	 := 0.3
p_info_mingle	 := 0.3
p_info_contacts	 := 0.2
p_transfer_info	 := 0.3


Link.other_side(?loc : Location) : Location :=
  ego.endpoints.filter(?loc != alter).only()

Migrant.knows(?loc : Location) : bool :=
  ego.knowledge.filter(alter.subject = ?loc).size() >= 1

// error, if they don't know the location
Migrant.knowledge_about(?loc : Location) : Information :=
  ego.knowledge.filter(alter.subject = ?loc).only()

/*
 * ACTIVITIES WHILE STAYING
 */
// (== exchange_info)
Migrant.exchange_info(?other : Migrant) ->
  ?egoExclusive := ego.knowledge.filter(!?other.knows(alter.subject))
  ?otherExclusive := ?other.knowledge.filter(!ego.knows(alter.subject))
  ?otherArrived := ?other.location.type = "exit"
  // ego discover's the places other knows
  for ?info in ?otherExclusive do
    ego.discover_location(?info.subject)
  end
  // other discovers the places ego knows
  if (!?otherArrived) then
    for ?info in ?egoExclusive do
      ?other.discover_location(?info.subject)
    end
  end
  // exchange knowledge about the places both know now
  for ?info in ego.knowledge.filter(?other.knows(alter.subject)) do
    ?otherInfo := ?other.knowledge.filter(?info.subject = alter.subject).only()
    ego.exchange_beliefs(?info, ?otherInfo, ?otherArrived)
  end
  // TODO: link knowledge

ego.exchange_beliefs(?i1 : Information, ?i2 : Information, ?arrived : bool) ->
  // agent 1 evaluated the information differently, if agent 2 has already arrived (agent 1 definitely did not arrive yet)
  ?convince1 := if (?otherArrived) then convince^(1 / weight_arr) else convince
  ?convert1 := if (?otherArrived) then convert^(1 / weight_arr) else convince
  ?confuse1 := convince
  ?v1_q := receive_value(?i1.quality, ?i1.quality_trust, ?i2.quality, ?i2.quality_trust, ?convince1, ?convert1, ?confuse1)
  ?v1_r := receive_value(?i1.resources, ?i1.resources_trust, ?i2.resources_trust, ?i2.resources_trust, ?convince1, ?convert1, ?confuse1)
  ?d1_q := receive_doubt(?i1.quality, ?i1.quality_trust, ?i2.quality, ?i2.quality_trust, ?convince1, ?convert1, ?confuse1)
  ?d1_r := receive_doubt(?i1.resources, ?i1.resources_trust, ?i2.resources_trust, ?i2.resources_trust, ?convince1, ?convert1, ?confuse1)
  ?i1.quality := ?v1_q / (1 - ?d1_q)
  ?i1.quality_trust := 1 - ?d1_q
  ?i1.resources := ?v1_q / (1 - ?d1_q)
  ?i1.resources_trust := 1 - ?d1_q
  // agent 2 does not update their knowledge, if they have arrived
  if (!?arrived) then
    ?v2_q := receive_value(?i2.quality, ?i2.quality_trust, ?i1.quality, ?i1.quality_trust, convince, convert, confuse)
    ?v2_r := receive_value(?i2.resources, ?i2.resources_trust, ?i1.resources_trust, ?i1.resources_trust, convince, convert, confuse)
    ?d2_q := receive_doubt(?i2.quality, ?i2.quality_trust, ?i1.quality, ?i1.quality_trust, convince, convert, confuse)
    ?d2_r := receive_doubt(?i2.resources, ?i2.resources_trust, ?i1.resources_trust, ?i1.resources_trust, convince, convert, confuse)
    ?i2.quality := ?v2_q / (1 - ?d2_q)
    ?i2.quality_trust := 1 - ?d2_q
    ?i2.resources := ?v2_q / (1 - ?d2_q)
    ?i2.resources_trust := 1 - ?d2_q
  end

Migrant.receive_value(?v1 : real, ?t1 : real, ?v2 : real, ?t2 : real, ?ci : real, ?ce : real, ?cu : real) real :=
  ?t * ?d_pcv * ?v + ?d * ?t_pcv * ?ci * ?v_pcv + ?t * ?t_pcv * (1.0 - ?cu * ?dist_pcv) * ((1.0 - ?ce) * v + ?ce * ?v_pcv)
where ?t := ?t1
      ?d := 1 - ?t
      ?v := ?v1
      ?t_pcv := ego.limit(0.000001, ?t2 + ego.unf_delta(error), 0.99999)
      ?d_pcv := 1.0 - ?t_pcv
      ?v_pcv := ego.max(0.0, ?v2 + ego.unf_delta(error))
      ?dist_pcv := abs(?v-?v_pcv) / (?v + ?v_pcv + 0.00001)

Migrant.receive_doubt(?v1 : real, ?t1 : real, ?v2 : real, ?t2 : real, ?ci : real, ?ce : real, ?cu : real) real :=
  ?d * ?d_pcv + ?d * ?t_pcv * (1.0 - ?ci) + ?t * ?t_pcv * ?cu * ?dist_pcv
where ?t := ?t1
      ?d := 1 - ?t
      ?v := ?v1
      ?t_pcv := ego.limit(0.000001, ?t2 + ego.unf_delta(error), 0.99999)
      ?d_pcv := 1.0 - ?t_pcv
      ?v_pcv := ego.max(0.0, ?v2 + ego.unf_delta(error))
      ?dist_pcv := abs(?v-?v_pcv) / (?v + ?v_pcv + 0.00001)

Migrant.unf_delta(?x : real) : real := random() * 2 * x - x
Migrant.limit(?mi : real, ?v : real, ?ma : real) := min(?ma, max(?v, ?mi))

Migrant.discover_location(?loc : Location) ->
  ?k := new Information()
  ?k.owner := ego
  ?k.subject := ?loc
  ?k.quality := qual_exp
  ?k.quality_trust := qual_exp_trust
  ?k.resources := res_exp
  ?.resources_trust := res_exp_trust

// (== costs_stay)
Migrant
  | !ego.in_transit
  @ 1 // TODO: rate
  -> ego.capital += ben_resources * ego.location.resources - costs_stay

// (== explore)
Migrant
 | !ego.in_transit
 @ 1 // TODO: rate
 -> ego.explore_at(ego.location, speed_expl_stay)


Migrant.explore_at(?loc : Location, ?speed : real) ->
  if (ego.knows(ego.location)) then
    ?k := ego.knowledge_about(ego.location)
  else
    ego.discover_location(?loc)
    ?k := ego.knowledge_about(ego.location)
  end
  ?k.quality := ego.weighted_average(?k.quality, ego.location.quality, ?speed)
  ?k.resources := ego.weighted_average(?k.resources, ego.location.quality, ?speed)
  ?k.quality_trust := ego.weighted_average(?k.quality_trust, 0.999999, ?speed) // TODO: why the -eps
  ?k.resources_trust := ego.weighted_average(?k.resources_trust, 0.999999, ?speed)
  // TODO: knowledge about links, see explore_at
  //if (allow_indirect) then
  //  for ?link in ?loc.links do
  //
  //  end
  //end

Migrant.explore_move() ->
  ego.explore_at(ego.destination, speed_expl_move)
  // TODO: the rest of explore_move that handles link knowledge


Migrant.weighted_average(?val : real, ?target : real, ?weight : real) :=
  ?val * (1-?weight) + ?target * ?weight

// (== mingle)
// the making contact part of mingle
Migrant
  | !ego.in_transit && ego.contacts.size() < n_contacts_max
  @ ?people.size() * p_keep_contact
  -> ego.contacts += ?people.random()
where ?people := (ego.location.migrants - ego).filter(alter.contacts.size() < n_contacts_max)

// the exchanging info part of mingle
Migrant
  | !ego.in_transit
  @ ?people.size() * p_info_mingle
  -> ?other := ?people.random()
     ego.exchange_info(?other)
where ?people := ego.location.migrants - ego

/*
 * MOVING AROUND
 */
Migrant.move_rate() : real := 0.5

// (== decide_move)
Migrant.decide_destination() : Location :=
  (ego.location.links.collect(alter.endpoints) - ego.location).argMax(ego.quality(alter))

// (== quality)
Migrant.quality(?loc : Location) : real :=
  if ?infos.isEmpty() then ?closeness + random() * 0.1 // TODO: what shall happen, when there is no knowledge
  else ?quality + ?position + ?resources
where ?infos := ego.knowledge.filter(alter.subject = ego.location)
      ?info := ?infos.only()
      ?quality := ?info.quality * ?info.quality_trust
      ?closeness := ?loc.x * qual_weight_x
      ?resources := ?info.resources * ?info.resources_trust * qual_weight_res

// (== costs_move)
Migrant.moveCost(?destination : Location) : real :=
  costs_move * ?destination.friction

// decide to move to a new location
Migrant
  | ego.capital >= 0 && !ego.in_transit
  @ 1 // TODO: rate
  -> ego.in_transit := true
     ego.destination := ego.decide_destination()
     ego.capital -= ego.move_cost(ego.destination)

// people in transit arrive at their destination
Migrant
  | ego.in_transit
  @ 1 // TODO: rate
  -> ego.location := ego.destination
     ego.in_transit := false
     if ego.location.type = "exit" then ego.die() end // arrival

// (== handle_departures)
World
  | true
  @ departure_rate
  -> ?migrant := new Migrant(capital := ini_capital)
     ?migrant.location := Location.all.filter(alter.type = "entry").random() // TODO initial contacts, knowledge