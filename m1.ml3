Migrant(
  capital : real,
  in_transit : bool
)

Location(
  x : real,
  y : real,
  type : {"std", "entry", "exit"},
  quality : real,
  resources
)

Information(
  quality : real,
  resources : real,
  quality_trust : real,
  resources_trust : real
)

Link(
  type : {"slow", "fast"},
  friction : real,
  distance : real
)

singleton World()

location:Location[1]<->[n]Migrant:migrants // migrants to locations
destination:Location[1]<->[n]Migrant:incoming // migrants on the move linked to their distination
links:Link[n]<->[n]Location:endpoints // location to the link object to another location
knowledge:Information[n]<->[1]Migrant:owner // migrants to their knowledge
subject:Location[1]<->[n]Information:information // pieces of information to the subject location
contacts:Migrant[n]<->[n]Migrant:contacts // contact network

weight_friction	 := 0.3
weight_control	 := 0.8
weight_info		 := 0.3
weight_resources := 0.5

n_ini_contacts	 := 10
ini_capital 	 := 500.0
costs_stay		 := 1.0
ben_resources	 := 5.0
costs_move		 := 5.0

p_keep_contact 	 := 0.3
p_info_mingle	 := 0.3
p_info_contacts	 := 0.2
p_transfer_info	 := 0.3


Link.other_side(?loc : Location) : Location :=
  ego.endpoints.filter(?loc != alter).only()

Migrant.knows(?loc : Location) : bool :=
  ego.knowledge.filter(alter.subject = ?loc).size() >= 1

// error, if they don't know the location
Migrant.knowledge_about(?loc : Location) : Information :=
  ego.knowledge.filter(alter.subject = ?loc).only()

/*
 * ACTIVITIES WHILE STAYING
 */
// (== exchange_info)
Migrant.exchange_info(?other : Migrant) ->
  ?egoExclusive := ego.knowledge.filter(!?other.knows(alter.subject))
  ?otherExclusive := ?other.knowledge.filter(!ego.knows(alter.subject))
  ?egoCommon := ego.knowledge - ?ego.egoExclusive
  ?otherCommon := ?other.knowledge - ?otherExclusive
  ?arrived := ?other.location.type = "exit"
  ?convince := if (?arrived) then convince^(1 / weight_arr) else convince
  ?convert := if (?arrived) then convert^(1 / weight_arr) else convince
  ?confuse := convince
  ?error := error
  // TODO: the actual exchange ...

Migrant.discover(?loc : Location) ->
  ?k := new Information()
  ?k.owner := ego
  ?k.subject := ?loc
  ?k.quality := qual_exp
  ?k.quality_trust := qual_exp_trust
  ?k.resources := res_exp
  ?.resources_trust := res_exp_trust

// (== costs_stay)
Migrant
  | !ego.in_transit
  @ 1 // TODO: rate
  -> ego.capital += ben_resources * ego.location.resources - costs_stay

// (== explore)
Migrant
 | !ego.in_transit
 @ 1 // TODO: rate
 -> ego.explore_at(ego.location, speed_expl_stay)


Migrant.explore_at(?loc : Location, ?speed : real) ->
  if (ego.knows(ego.location)) then
    ?k := ego.knowledge_about(ego.location)
  else
    ego.discover(?loc)
    ?k := ego.knowledge_about(ego.location)
  end
  ?k.quality := ego.weighted_average(?k.quality, ego.location.quality, ?speed)
  ?k.resources := ego.weighted_average(?k.resources, ego.location.quality, ?speed)
  ?k.quality_trust := ego.weighted_average(?k.quality_trust, 0.999999, ?speed) // TODO: why the -eps
  ?k.resources_trust := ego.weighted_average(?k.resources_trust, 0.999999, ?speed)
  // TODO: knowledge about links, see explore_at
  //if (allow_indirect) then
  //  for ?link in ?loc.links do
  //
  //  end
  //end

Migrant.explore_move() ->
  ego.explore_at(ego.destination, speed_expl_move)
  // TODO: the rest of explore_move that handles link knowledge


Migrant.weighted_average(?val : real, ?target : real, ?weight : real) :=
  ?val * (1-?weight) + ?target * ?weight

// (== mingle)
// the making contact part of mingle
Migrant
  | !ego.in_transit && ego.contacts.size() < n_contacts_max
  @ ?people.size() * p_keep_contact
  -> ego.contacts += ?people.random()
where ?people := (ego.location.migrants - ego).filter(alter.contacts.size() < n_contacts_max)

// the exchanging info part of mingle
Migrant
  | !ego.in_transit
  @ ?people.size() * p_info_mingle
  -> ?other := ?people.random()
     ego.exchange_info(?other)
where ?people := ego.location.migrants - ego

/*
 * MOVING AROUND
 */
Migrant.move_rate() : real := 0.5

// (== decide_move)
Migrant.decide_destination() : Location :=
  (ego.location.links.collect(alter.endpoints) - ego.location).argMax(ego.quality(alter))

// (== quality)
Migrant.quality(?loc : Location) : real :=
  if ?infos.isEmpty() then ?closeness + random() * 0.1 // TODO: what shall happen, when there is no knowledge
  else ?quality + ?position + ?resources
where ?infos := ego.knowledge.filter(alter.subject = ego.location)
      ?info := ?infos.only()
      ?quality := ?info.quality * ?info.quality_trust
      ?closeness := ?loc.x * qual_weight_x
      ?resources := ?info.resources * ?info.resources_trust * qual_weight_res

// (== costs_move)
Migrant.moveCost(?destination : Location) : real :=
  costs_move * ?destination.friction

// decide to move to a new location
Migrant
  | ego.capital >= 0 && !ego.in_transit
  @ 1 // TODO: rate
  -> ego.in_transit := true
     ego.destination := ego.decide_destination()
     ego.capital -= ego.move_cost(ego.destination)

// people in transit arrive at their destination
Migrant
  | ego.in_transit
  @ 1 // TODO: rate
  -> ego.location := ego.destination
     ego.in_transit := false
     if ego.location.type = "exit" then ego.die() end // arrival

// (== handle_departures)
World
  | true
  @ departure_rate
  -> ?migrant := new Migrant(capital := ini_capital)
     ?migrant.location := Location.all.filter(alter.type = "entry").random() // TODO initial contacts, knowledge